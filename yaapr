#! /usr/bin/python3

import os
import sys
import time
import random
import string
import logging
import subprocess
import argparse
import configparser
import urllib.request
from datetime import datetime
from operator import itemgetter
from systemd.journal import JournalHandler

def parse_section(section):
   """
   Convert a configparser ini section into a dict for use throughout the program.

   ### Parameters:
   - section (configparser.Section): A section from a configparser ini file.

   ### Returns:
   - cur (dict): A dictionary derived from the configparser.Section
   """

    return cur


def check_path(cur_name, cur_path, logger):
    logger.info('check_path: {0} - {1}'.format(cur_name, cur_path))
    result = True

    # if directory doesn't exist
    if not os.path.exists(cur_path):
        # and we can't write to it's parent
        if not os.access(os.path.dirname(cur_path), os.W_OK):
            logger.warning('check_path: {0} - Unable to create {1}'.format(cur_name, cur_path))
            result = False
        else:
            logger.info('check_path: {0} - Creating {1}'.format(cur_name, cur_path))
            os.mkdir(cur_path)
    # else if directory does exist
    else:
        # but we can't write to it
        if not os.access(cur_path, os.W_OK):
            logger.warning('check_path: {0} - Unable to write to {1}'.format(cur_name, cur_path))
            result = False

    return result


def check_tags(cur_name, cur_tags, logger):
    logger.info('check_tags: {0} - {1}'.format(cur_name, cur_tags))
    result = True

    # check to see if we have any invalid characters in skip_tags, esp spaces
    if cur_tags.find(' ') > -1:
        logger.warning('check_tags: {0} - Invalid characters [spaces] detected in skip_tags'.format(cur_name))
        result = False

    return result


def check_url(cur_name, cur_url, logger):
    logger.info('check_url: {0} - {1}'.format(cur_name, cur_url))
    result = True

    # verify we can access the specified url
    try:
        logger.info('check_url: {0} - Verifying url {1}'.format(cur_name, cur_url))
        response = urllib.request.urlopen(cur_url)
    except Exception as e:
        logger.debug('check_url: {0} - {1} - {2}'.format(cur_name, cur_url, str(e)))
        result = False

    return result


def check_cmd(cur_cmd, logger):
    logger.info('check_cmd: {0}'.format(cur_cmd))
    result = True

    # command exists
    if os.path.exists(cur_cmd):
        # but we don't have permission to execute it
        if not os.access(cur_cmd, os.X_OK):
            logger.warning('check_cmd: {0} exists but isn\'t executable'.format(cur_cmd))
            result = False
    else:
        logger.warning('check_cmd: {0} doesn\'t exist'.format(cur_cmd))
        result = False

    return result


# once checks have been run we can safely clone a git repo and verify the
# various files we need
def prep_cache(cur_name, cur_url, cur_branch, cur_dir, logger):
    logger.info('prep_cache: {0} - {1}'.format(cur_name, cur_url))
    result = True

    # if git_dir exists, try to run git pull from within it
    if os.path.exists(cur_dir):
        logger.info('prep_cache: {0} - Running git pull under {1}'.format(cur_name, cur_dir))

        cmd_list = [ '/usr/bin/git', 'pull' ]
        pull_result = subprocess.run(cmd_list, cwd=cur_dir, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        logger.debug('prep_cache: {0} - {1}'.format(cur_name, ' '.join(cmd_list)))

        # if pull was successful, try to checkout the specififed branch
        if pull_result.returncode == 0:
            logger.info('prep_cache: {0} - Checking out {1} on {2}'.format(cur_name, cur_branch, cur_dir))

            cmd_list = [ '/usr/bin/git', 'checkout', cur_branch ]
            checkout_result = subprocess.run(cmd_list, cwd=cur_dir, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            logger.debug('prep_cache: {0} - {1}'.format(cur_name, ' '.join(cmd_list)))
            logger.debug(checkout_result.stdout.strip())

            # couldn't switch branches
            if checkout_result.returncode != 0:
                logger.warning('prep_cache: {0} - Error checking out branch {1} on {2}'.format(cur_name, cur_branch, cur_dir))
                logger.debug(checkout_result.stderr.strip())
                result = False
        else:
            logger.warning('prep_cache: {0} - Error running git pull on {1}'.format(cur_name, cur_dir))
            logger.debug(pull_result.stderr.strip())
            result = False
    else:
        logger.info('prep_cache: {0} - Git directory doesn\'t exist {1}'.format(cur_name, cur_dir))

        cmd_list = [ '/usr/bin/git', 'clone', cur_url, '-b', cur_branch, cur_dir ]
        clone_result = subprocess.run(cmd_list, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        logger.debug('prep_cache: {0} - {1}'.format(cur_name, ' '.join(cmd_list)))
        logger.debug(clone_result.stderr.strip())

        if clone_result.returncode != 0:
            logger.warning('prep_cache: {0} - Failed cloning repository {1}'.format(cur_name, cur_url))
            result = False

    return result


# finally, run the ansible playbook
def exec_play(cur_name, cur_play, cur_cfg, cur_tags, cache_dir, log_file, logger):
    logger.info('exec_play: {0} - {1}'.format(cur_name, cur_play))
    result = True

    apull = '/usr/bin/ansible-pull'
    aplay = '/usr/bin/ansible-playbook'

    if os.path.exists(cur_play):
        if os.path.exists(cur_cfg):
            new_env = os.environ.copy()
            new_env['ANSIBLE_CONFIG'] = '{0}'.format(cur_cfg)

            cmd_list = [aplay, '-i', 'localhost,', '-c', 'local', '--check', '--skip-tags={0}'.format(cur_tags), cur_play ]
            logger.info('exec_play: {0} - Running playbook {1}'.format(cur_name, cur_play))
            logger.debug(' '.join(cmd_list))

            with open(os.path.join(cache_dir, log_file), "wb") as out:
                aplay_result = subprocess.run(cmd_list, env=new_env, stdout=out, stderr=subprocess.STDOUT, encoding='utf-8')

            if aplay_result.returncode == 0:
                logger.info('exec_play: {0} - Playbook successfully run'.format(cur_name))
            else:
                # logger.warning(aplay_result.stderr.strip())
                logger.info('exec_play: {0} - Playbook terminated with errors'.format(cur_name))
                # logger.debug(aplay_result.stdout.strip())
                result = False
        else:
            logger.warning('exec_play: {0} - Config file missing {1}'.format(cur_name, cur_cfg))
            result = False
    else:
        logger.warning('exec_play: {0} - Play file missing {1}'.format(cur_name, cur_play))
        result = False

    return result


def ParseCommandLineArguments():
    arg_parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter, description="Ansible playbook runner.")
    arg_parser.add_argument('-i', '--ini', type=str, help="Path to the ini file.", default="/etc/yaapr/yaapr.ini")

    return arg_parser


# maybe add a command line argument so the user can supply a section/tag to process
def main():
    result = True
    commands = [ '/usr/bin/ansible-playbook', '/usr/bin/ansible-pull', '/usr/bin/git' ]

    arg_parser = ParseCommandLineArguments()
    args = arg_parser.parse_args()

    # catch ini errors, especially duplicate section names
    try:
        config = configparser.ConfigParser()
        config.read(args.ini)
    except Exception as e:
        print('Error: ' + str(e))
        exit(1)

    # set up our list, we'll sort sections by priority the user gets to decide
    # which order they're run in
    temp_list = []
    sort_field = 'priority'

    # TODO: Validate logdir to ensure we can open and write to the logfile
    log_path = config['DEFAULT']['logdir']

    logger = logging.getLogger("runner")
    logger.setLevel(logging.DEBUG)
    filename = os.path.join(config['DEFAULT']['logdir'], 'yaapr.log')
    fileHandler = logging.FileHandler(filename, mode="a")
    formatter = logging.Formatter("%(asctime)s %(levelname)s %(message)s", "%Y-%m-%d %H:%M:%S")
    fileHandler.setFormatter(formatter)
    logger.addHandler(fileHandler)

    logger.info('main: Starting playbook runnner')

    # convert each section to a dict and append to a list
    for section in config:
        # only parse sections with a priority, the presumption is that
        # that any section with a priority is an ansible playbook
        if config[section].getint('priority') is not None:
            logger.info('main: Parsing section {0}'.format(section))
            temp_list.append(parse_section(config[section]))
        else:
            if section != 'DEFAULT':
                logger.warning('main: ini file section [{0}] doesn\'t contain a priority, skipping.'.format(section))

    # verify the requisite binaries exist and that we have permission to
    # execute them
    for cmd in commands:
        if result:
            result = check_cmd(cmd, logger)

    # sort sections by priority
    play_list = sorted(temp_list, key = lambda i: i['priority'])

    # don't proceed if commands don't exist or aren't executable
    if result:
        for item in play_list:
            result = True

            logger.info('main: Processing section ' + item['name'])

            if not check_path(item['name'], item['cache_dir'], logger):
                result = False

            if not check_path(item['name'], item['log_dir'], logger):
                result = False

            if not check_tags(item['name'], item['skip_tags'], logger):
                result = False

            if not check_url(item['name'], item['git_url'], logger):
                result = False

            if result and prep_cache(item['name'], item['git_url'], item['git_branch'], item['git_dir'], logger):
                result = exec_play(item['name'], item['play_file'], item['cfg_file'], item['skip_tags'], item['cache_dir'], item['log_file'], logger)

    logger.info('main: Stopping playbook runnner')


if __name__ == "__main__":
    sys.exit(main())
